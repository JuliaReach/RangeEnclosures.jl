var documenterSearchIndex = {"docs":
[{"location":"lib/methods/#Methods","page":"Methods","title":"Methods","text":"This section describes systems methods implemented in RangeEnclosures.jl.\n\nPages = [\"methods.md\"]\nDepth = 3","category":"section"},{"location":"lib/methods/#The-enclose-function","page":"Methods","title":"The enclose function","text":"","category":"section"},{"location":"lib/methods/#Utility-functions","page":"Methods","title":"Utility functions","text":"","category":"section"},{"location":"lib/methods/#RangeEnclosures.enclose","page":"Methods","title":"RangeEnclosures.enclose","text":"enclose(f, dom[, solver=NaturalEnclosure()]; kwargs...)\n\nReturn a range enclosure of a univariate or multivariate function on the given domain.\n\nInput\n\nf      – function or AbstractPolynomialLike object\ndom    – hyperrectangular domain, either a unidimensional  Interval or             a multidimensional IntervalBox\nsolver – (optional, default: NaturalEnclosure()) choose one among the             available solvers; you can get a list of available solvers with             subtypes(AbstractEnclosureAlgorithm)\nkwargs – optional keyword arguments passed to the solver; for available             options see the documentation of each solver\n\nOutput\n\nAn interval enclosure of the range of f over dom.\n\nExamples\n\njulia> enclose(x -> 1 - x^4 + x^5, interval(0, 1)) # use default solver\n[0.0, 2.0]_com_NG\n\njulia> enclose(x -> 1 - x^4 + x^5, interval(0, 1), TaylorModelsEnclosure())\n[0.812499, 1.09376]_com_NG\n\nA vector of solvers can be passed in the solver options. Then, the result is obtained by intersecting the range enclosure of each solver.\n\njulia> enclose(x -> 1 - x^4 + x^5, interval(0, 1), [TaylorModelsEnclosure(), NaturalEnclosure()])\n[0.812499, 1.09376]_trv_NG\n\n\n\n\n\n\n","category":"function"},{"location":"lib/methods/#RangeEnclosures.relative_precision","page":"Methods","title":"RangeEnclosures.relative_precision","text":"relative_precision(x::Interval, xref::Interval)\n\nReturn the relative precision of an interval with respect to a reference interval.\n\nInput\n\nx    – test interval\nxref – reference interval\n\nOutput\n\nLeft and right relative precision (in %) computed as\n\nrleft = (inf(xref) - inf(x)) / diam(xref) * 100%\nrright = (sup(x) - sup(xright)) / diam(xref) * 100%\n\nExamples\n\njulia> xref = interval(-1.2, 4.6)\n[-1.20001, 4.60001]_com\n\njulia> x = interval(-1.25, 7.45)\n[-1.25001, 7.45001]_com\n\njulia> relative_precision(x, xref)\n(0.8620689655172422, 49.13793103448277)\n\nAlgorithm\n\nThis function measures the relative precision of the result in a more informative way than taking the scalar overestimation because it evaluates the precision of the lower and the upper bounds separately (cf. Althoff et al. [AGK18], Eq. (20)).\n\n\n\n\n\n","category":"function"},{"location":"about/#About","page":"About","title":"About","text":"This page contains some general information about this project, and recommendations about contributing.\n\nPages = [\"about.md\"]","category":"section"},{"location":"about/#Contributing","page":"About","title":"Contributing","text":"If you like this package, consider contributing! You can send bug reports (or fix them and send your code), add examples to the documentation, or propose new features.\n\nBelow some conventions that we follow when contributing to this package are detailed. For specific guidelines on documentation, see the Documentations Guidelines wiki.","category":"section"},{"location":"about/#Branches-and-pull-requests-(PR)","page":"About","title":"Branches and pull requests (PR)","text":"We use a standard pull request policy: You work in a private branch and eventually add a pull request, which is then reviewed by other programmers and merged into the master branch.\n\nEach pull request should be pushed in a new branch with the name of the author followed by a descriptive name, e.g., mforets/my_feature. If the branch is associated to a previous discussion in one issue, we use the name of the issue for easier lookup, e.g., mforets/7.","category":"section"},{"location":"about/#Unit-testing-and-continuous-integration-(CI)","page":"About","title":"Unit testing and continuous integration (CI)","text":"This project is synchronized with GitHub Actions such that each PR gets tested before merging (and the build is automatically triggered after each new commit). For the maintainability of this project, it is important to make all unit tests pass.\n\nTo run the unit tests locally, you can do:\n\njulia> using Pkg\n\njulia> Pkg.test(\"RangeEnclosures\")\n\nWe also advise adding new unit tests when adding new features to ensure long-term support of your contributions.","category":"section"},{"location":"about/#Contributing-to-the-documentation","page":"About","title":"Contributing to the documentation","text":"New functions and types should be documented according to our guidelines directly in the source code.\n\nYou can view the source code documentation from inside the REPL by typing ? followed by the name of the type or function. For example, the following command will print the documentation of the enclose function:\n\njulia> ?enclose\n\nThis documentation you are currently reading is written in Markdown, and it relies on Documenter.jl to produce the HTML layout. The sources for creating this documentation are found in docs/src. You can easily include the documentation that you wrote for your functions or types there (see the Documenter.jl guide or our sources for examples).\n\nTo generate the documentation locally, run make.jl, e.g., by executing the following command in the terminal:\n\n$ julia --color=yes docs/make.jl","category":"section"},{"location":"about/#Credits","page":"About","title":"Credits","text":"","category":"section"},{"location":"about/#Core-developers","page":"About","title":"Core developers","text":"The RangeEnclosures.jl library is maintained by (in alphabetic order):\n\nLuca Ferranti, University of Vasaa\nMarcelo Forets, Universidad de la República\nChristian Schilling, Aalborg University","category":"section"},{"location":"about/#Contributors","page":"About","title":"Contributors","text":"Huge thanks to all the contributors.","category":"section"},{"location":"about/#Acknowledgments","page":"About","title":"Acknowledgments","text":"We are grateful to the following persons for enlightening discussions during the preparation of this package:\n\nLuis Benet\nBenoît Legat\nDavid P. Sanders\n\nDuring Summer 2022, this project was financially supported by Google through the Google Summer of Code program. During Summer 2019, this project was financially supported by Julia through the Julia Season of Contributions program.","category":"section"},{"location":"lib/types/#Types","page":"Types","title":"Types","text":"This section describes systems types implemented in RangeEnclosures.jl.\n\nPages = [\"types.md\"]\nDepth = 3","category":"section"},{"location":"lib/types/#RangeEnclosures.AbstractEnclosureAlgorithm","page":"Types","title":"RangeEnclosures.AbstractEnclosureAlgorithm","text":"AbstractEnclosureAlgorithm\n\nAbstract type for range enclosure algorithms.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#RangeEnclosures.AbstractDirectRangeAlgorithm","page":"Types","title":"RangeEnclosures.AbstractDirectRangeAlgorithm","text":"AbstractDirectRangeAlgorithm <: AbstractEnclosureAlgorithm\n\nAbstract type for range enclosure algorithms that directly evaluate the functions over a given domain.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#RangeEnclosures.AbstractIterativeRangeAlgorithm","page":"Types","title":"RangeEnclosures.AbstractIterativeRangeAlgorithm","text":"AbstractIterativeRangeAlgorithm <: AbstractEnclosureAlgorithm\n\nAbstract type for algorithms that iteratively bound the range of a function over a given domain.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#RangeEnclosures.AffineArithmeticEnclosure","page":"Types","title":"RangeEnclosures.AffineArithmeticEnclosure","text":"AffineArithmeticEnclosure <: AbstractDirectRangeAlgorithm\n\nData type to bound the range of f over X using affine arithmetic. See AffineArithmetic.jl for more details.\n\nNotes\n\nTo use this algorithm, you need to load AffineArithmetic.jl. Note also that AffineArithmetic.jl currently supports only arithmetic operations.\n\nExamples\n\njulia> using AffineArithmetic\n\njulia> enclose(x -> 1 - x^4 + x^5, interval(0, 1), AffineArithmeticEnclosure())\n[0.0625, 2.0]_com_NG\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#RangeEnclosures.BranchAndBoundEnclosure","page":"Types","title":"RangeEnclosures.BranchAndBoundEnclosure","text":"BranchAndBoundEnclosure <: AbstractIterativeRangeAlgorithm\n\nData type to bound the range of f over X using the branch and bound algorithm.\n\nFields\n\nmaxdepth (default 10): maximum depth of the search tree\ntol (default 1e-3): tolerance to compute the range of the function\n\nAlgorithm\n\nThe algorithm evaluates a function f over an interval X. If the maximum depth is reached or the width of f(X) is below the tolerance, the algorithm returns the computed range; otherwise it bisects the interval/interval box.\n\nThe algorithm also looks at the sign of the derivative / gradient to see if the range can be computed directly. By default, the derivative / gradient is computed using ForwardDiff.jl, but a custom value can be passed via the df keyword argument to enclose.\n\nExamples\n\njulia> enclose(x -> 1 - x^4 + x^5, interval(0, 1), BranchAndBoundEnclosure()) # default parameters\n[0.914022, 1.00004]_trv_NG\n\njulia> enclose(x -> 1 - x^4 + x^5, interval(0, 1), BranchAndBoundEnclosure(tol=1e-2, maxdepth=7); df=(x -> -4x^3 + 5x^4))\n[0.88221, 1.00098]_trv_NG\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#RangeEnclosures.NaturalEnclosure","page":"Types","title":"RangeEnclosures.NaturalEnclosure","text":"NaturalEnclosure <: AbstractDirectRangeAlgorithm\n\nData type to bound the range of f over X using natural enclosure, i.e., to evaluate f(X) with interval arithmetic.\n\nExamples\n\njulia> enclose(x -> 1 - x^4 + x^5, interval(0, 1), NaturalEnclosure())\n[0.0, 2.0]_com_NG\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#RangeEnclosures.MeanValueEnclosure","page":"Types","title":"RangeEnclosures.MeanValueEnclosure","text":"MeanValueEnclosure\n\nData type to bound the range of f over X using the mean value form, that is the range is bounded by the expression f(Xc) + f(X) * (X - Xc), where Xc is the midpoint of X and f' is the derivative of f (gradient in the multivariate case).\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#RangeEnclosures.MooreSkelboeEnclosure","page":"Types","title":"RangeEnclosures.MooreSkelboeEnclosure","text":"MooreSkelboeEnclosure{T} <: AbstractIterativeRangeAlgorithm\n\nData type to bound the range of f over X using the Moore-Skelboe algorithm, which rigorously computes the global minimum and maximum of the function. See IntervalOptimisation.jl for more details.\n\nFields\n\nstructure – (default: HeapedVector) the way in which vector elements                are kept arranged; possible options are HeapedVector and SortedVector\ntol       – (default 1e-3) tolerance to which the optima are computed\n\nNotes\n\nTo use this algorithm, you need to load IntervalOptimisation.jl.\n\nExamples\n\njulia> using IntervalOptimisation\n\njulia> enclose(x -> 1 - x^4 + x^5, interval(0, 1), MooreSkelboeEnclosure()) # default parameters\n[0.916034, 1.00213]_com\n\njulia> enclose(x -> 1 - x^4 + x^5, interval(0, 1), MooreSkelboeEnclosure(; tol=1e-2))\n[0.900812, 1.0326]_com\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#RangeEnclosures.SumOfSquaresEnclosure","page":"Types","title":"RangeEnclosures.SumOfSquaresEnclosure","text":"SumOfSquaresEnclosure{T} <: AbstractIterativeRangeAlgorithm\n\nData type to bound the range of f over X using sum-of-squares optimization. See SumOfSquares.jl for more details\n\nFields\n\nbackend – backend used to solve the optimization problem; a list of available backends            can be found here\norder – (default 5), maximum degree of the SDP relaxation\n\nNotes\n\nTo use this solver, you need to load SumOfSquares.jl and a backend.\n\nSince the optimization problem is solved numerically and not with interval arithmetic, the result of this algorithm is not rigorous.\n\nExamples\n\njulia> using SumOfSquares, SDPA, DynamicPolynomials\n\njulia> backend = SDPA.Optimizer;\n\njulia> @polyvar x;\n\njulia> enclose(-x^3/6 + 5x, interval(1, 4), SumOfSquaresEnclosure(; backend=backend)) # default parameters\n[4.83333, 10.541]_com\n\njulia> enclose(-x^3/6 + 5x, interval(1, 4), SumOfSquaresEnclosure(; backend=backend, order=6))\n[4.83333, 10.541]_com\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#RangeEnclosures.TaylorModelsEnclosure","page":"Types","title":"RangeEnclosures.TaylorModelsEnclosure","text":"TaylorModelsEnclosure <: AbstractDirectRangeAlgorithm\n\nData type to bound the range of f over X using Taylor models. See TaylorModels.jl for more details.\n\nFields\n\norder     – (default: 10) order of the Taylor model used to compute                an enclosure of f over dom\nnormalize – (default: true) if true, normalize the Taylor model                on the unit symmetric box around the origin\n\nNotes\n\nTo use this solver, you need to load TaylorModels.jl and a backend.\n\nExamples\n\njulia> using TaylorModels\n\njulia> enclose(x -> 1 - x^4 + x^5, interval(0, 1), TaylorModelsEnclosure()) # default parameters\n[0.812499, 1.09376]_com_NG\n\njulia> enclose(x -> 1 - x^4 + x^5, interval(0, 1), TaylorModelsEnclosure(; order=4))\n[0.781249, 1.12501]_trv_NG\n\n\n\n\n\n","category":"type"},{"location":"bibliography/#Bibliography","page":"Bibliography","title":"Bibliography","text":"M. Althoff, D. Grebenyuk and N. Kochdumper. Implementation of Taylor models in CORA 2018. In: Applied Verification of Continuous and Hybrid Systems (ARCH18), Vol. 54 of EPiC Series in Computing, edited by G. Frehse, M. Althoff, S. Bogomolov and T. T. Johnson (EasyChair, 2018); pp. 145–173.\n\n\n\n","category":"section"},{"location":"#RangeEnclosures.jl","page":"Home","title":"RangeEnclosures.jl","text":"A Julia package to compute range enclosures of real-valued functions.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Computation of lower and upper bounds of real-valued functions, either univariate or multivariate, over hyperrectangular (i.e. box shaped) domains.\nThe following solvers are always available (using the package IntervalArithmetic.jl):\nNaturalEnclosure\nMeanValueEnclosure\nBranchAndBoundEnclosure\nThe following solvers are available upon loading other packages:\nMooreSkelboeEnclosure, which requires IntervalOptimisation.jl\nTaylorModelsEnclosure, which requires TaylorModels.jl\nSumOfSquaresEnclosure, which requires SumOfSquares.jl\nAffineArithmeticEnclosure, which requires AffineArithmetic.jl","category":"section"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"The package exports one single function, enclose, which receives a Julia function, a domain, and (optionally) a solver and additional options passed to the solver. See the README.md file for the basic usage, or consult the source code docstrings, either in the REPL or in the github repository source code","category":"section"},{"location":"#Library-Outline","page":"Home","title":"Library Outline","text":"Pages = [\n    \"lib/types.md\",\n    \"lib/methods.md\"\n]\nDepth = 2","category":"section"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"This tutorial will teach you how to use RangeEnclosures. First, we will give a basic overview of the package and its functionalities. Next, we will discuss in more detail how to use the package in different scenarios (1D, higher dimension, using algorithms from external libraries, etc.).","category":"section"},{"location":"tutorial/#Setup","page":"Tutorial","title":"Setup","text":"Assuming you have installed Julia, you can install the package from the Julia REPL with the following lines.\n\nusing Pkg\nPkg.add(\"RangeEnclosures\")\n\nThen you can load the package in the standard way.\n\nusing RangeEnclosures","category":"section"},{"location":"tutorial/#Overview","page":"Tutorial","title":"Overview","text":"RangeEnclosures is used to bound the range of a given function f. The main function provided by this package is enclose, and its basic usage is the following.\n\nenclose(f, D, solver; kwargs...)\n\nwhere\n\nf is the function whose range we want to bound,\nD is the domain over which we want to compute the range,\nsolver is the solver used to compute the range (which is optional; if not specified, the package will default to the NaturalEnclosure solver), and\nkwargs... are possible keyword arguments used by the solver.\n\nThe solvers can be divided into two families: direct solvers, which compute the range enclosure over the whole domain, and iterative solvers, which recursively split the domain into smaller subdomains to get a more accurate estimate. A detailed list of available solvers can be found here.","category":"section"},{"location":"tutorial/#Usage-Examples","page":"Tutorial","title":"Usage Examples","text":"","category":"section"},{"location":"tutorial/#A-one-dimensional-example","page":"Tutorial","title":"A one-dimensional example","text":"Suppose we want to compute the range of the function\n\nf(x) = -sum_k=1^5kxsinleft(frack(x-3)3right)\n\nover the domain D = -10 10.\n\nIf we call enclose without specifying the solver, it will evaluate f(D) using plain interval arithmetic (this is called natural enclosure), as the following example shows.\n\nf(x) = -sum(k*x*sin(k*(x-3)/3) for k in 1:5)\nD = interval(-10, 10)\nR = enclose(f, D)\n\nGenerally, using natural enclosures leads to unpleasantly large overestimates, which is due to the dependency problem. To overcome this, you may want to use some other solvers in your application. The next example bounds the range using the BranchAndBoundEnclosure solver.\n\nRbb = enclose(f, D, BranchAndBoundEnclosure())\n\nAs you can see, the result is much tighter now, while still being rigorous! The results can be visualized using Plots.jl.\n\nusing Plots\nusing RangeEnclosures: inf, sup\n\nfunction plot_box!(fig, box::IntervalBox{2}; label, alpha)\n    (x, y) = box\n    x = [inf(x), sup(x), sup(x), inf(x)]\n    y = [inf(y), inf(y), sup(y), sup(y)]\n    plot!(fig, x, y, seriesalpha=alpha, seriestype=:shape, label=label)\n    x, y\nend\n\nfig = plot(xlabel=\"x\", ylabel=\"f(x)\", legendfontsize=12, tickfontsize=12,\n           xguidefont=font(15, \"Times\"), yguidefont=font(15, \"Times\"))\nplot_box!(fig, IntervalBox(D, R), label=\"natural enclosure\", alpha=0.5)\nplot_box!(fig, IntervalBox(D, Rbb), label=\"branch and bound\", alpha=1)\nplot!(fig, f, -10, 10, lw=2, c=:black, label=\"f\")\nimport DisplayAs  #hide\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide","category":"section"},{"location":"tutorial/#Tuning-parameters","page":"Tutorial","title":"Tuning parameters","text":"Some solvers have parameters that can be tuned. For example, looking at the BranchAndBoundEnclosure documentation, we can see that it has two parameters, tol and maxdepth. If you want to use different values from the default ones, you can pass the parameters as keyword arguments to the solver constructor. For example, you can limit the depth of the search tree to 6 the following way:\n\nenclose(f, D, BranchAndBoundEnclosure(maxdepth=6))\n\nGenerally, tuning parameters can be a good idea to achieve the desired accuracy tradeoff in your application.","category":"section"},{"location":"tutorial/#Combining-different-solvers","page":"Tutorial","title":"Combining different solvers","text":"Sometimes there is no strictly \"best\" solver, as one solver might give a tighter estimate of the range's upper bound and another solver might give a tighter estimate on the lower bound. In this case, the results can be combined by taking the intersection. For example, let us consider the function g(x) = x^2 - 2x + 1, which we want to bound over the domain D_g = 0 4. Let us first use plain interval arithmetic:\n\ng(x) = x^2 - 2*x + 1\nDg = interval(0, 4)\nenclose(g, Dg, NaturalEnclosure()) # this is equivalent to enclose(g, Dg)\n\nNow let us bound the range using the MeanValueEnclosure solver, which uses the mean-value form of the function:\n\nenclose(g, Dg, MeanValueEnclosure())\n\nAs you can see, there is no clear winner and a better enclosure could be obtained by taking the intersection of the two results. This can be easily done in one command by passing a vector of solvers to enclose:\n\nenclose(g, Dg, [NaturalEnclosure(), MeanValueEnclosure()])","category":"section"},{"location":"tutorial/#Using-solvers-based-on-external-libraries","page":"Tutorial","title":"Using solvers based on external libraries","text":"Some of the available solvers are implemented in external libraries. To keep the start-up time of RangeEnclosures.jl low, these libraries are not imported by default. To use more solvers, these libraries need to be manually loaded. For example, suppose we want to bound the previous function using the Moore-Skelboe algorithm. Trying the following will fail:\n\nenclose(f, D, MooreSkelboeEnclosure())\n\nERROR: AssertionError: package 'IntervalOptimisation' not loaded (it is required for executing `enclose`)\n...\n\nThis is because the algorithm is implemented in IntervalOptimisation.jl and to use it you need to load that package first (note that you need to have it installed before loading it). Let us fix our example.\n\nusing IntervalOptimisation\nenclose(f, D, MooreSkelboeEnclosure())","category":"section"},{"location":"tutorial/#Bounding-multivariate-functions","page":"Tutorial","title":"Bounding multivariate functions","text":"While our previous examples were in one dimension, the techniques generalize to multivariate functions mathbbR^nrightarrowmathbbR, the only difference is that the domain, instead of being an interval, should be an IntervalBox. For example, consider the function\n\nh(x_1 x_2) = sin(x_1) - cos(x_2) - sin(x_1)cos(x_1)\n\nover the domain D_h = -5 5 times -5 5. An enclosure can be computed as follows.\n\nh(x) = sin(x[1]) - cos(x[2]) - sin(x[1]) * cos(x[1])\nDh = IntervalBox(interval(-5, 5), interval(-5, 5))\nRh = enclose(h, Dh, BranchAndBoundEnclosure())\n\nWe can visualize the result with the following script.\n\nx = y = -5:0.1:5\nf(x, y) = h([x, y])\nfig = plot(legend=:none, size=(800, 800), xlabel=\"x\", ylabel=\"y\", zlabel=\"h(x,y)\",\n           tickfontsize=18, guidefont=font(22, \"Times\"), zticks=[-2, 0, 2])\nsurface!(fig, x, y, [inf(Rh) for _ in x, _ in y], α=0.4)\nsurface!(fig, x, y, f.(x', y), zlims=(-4, 4))\nsurface!(fig, x, y, [sup(Rh) for _ in x, _ in y], α=0.4)\nDisplayAs.Text(DisplayAs.PNG(fig))  #hide","category":"section"},{"location":"tutorial/#Adding-a-new-enclosure-algorithm","page":"Tutorial","title":"Adding a new enclosure algorithm","text":"To add a new enclosure algorithm, or solver, just add a corresponding struct (let us call it MyEnclosure) and extend the method enclose, as the following code snippet demonstrates.\n\nusing RangeEnclosures\nimport RangeEnclosures: enclose\nusing RangeEnclosures: Interval, IntervalBox\n\nstruct MyEnclosure end\n\nfunction enclose(f::Function,\n                 D::Union{Interval,IntervalBox},\n                 solver::MyEnclosure; kwargs...)\n    # solver-specific implementation\nend\nnothing  # hide\n\nNote that the domain D can be of type Interval for univariate (n = 1) functions or of type IntervalBox for multivariate (n  1) functions.","category":"section"}]
}
